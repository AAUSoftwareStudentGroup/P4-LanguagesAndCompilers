-> := AST -> C
->:a := [AST C C C] -> [C C C]

AST[GlobalStatement:gs eof] -> C[GlobalDeclarations[GlobalDeclaration[FunctionPrototype[void main ( void )] ;] gd] Functions[Function[void main ( void ) { s }] f]]
    [gs GlobalDeclarations[EPSILON] Functions[EPSILON] Statement[EPSILON]] ->:a [GlobalDeclarations:gd Functions:f Statement:s]

[GlobalStatement[CompoundGlobalStatement:cgs] GlobalDeclarations:gd Functions:f Statement:s] ->:a [gd1 f1 s1]
    [cgs gd f s] ->:a [GlobalDeclarations:gd1 Functions:f1 Statement:s1]

[GlobalStatement[Interrupt:i] GlobalDeclarations:gd Functions:f Statement:s] ->:a [gd1 f1 s1]
    [i gd f s] ->:a [GlobalDeclarations:gd1 Functions:f1 Statement:s1]

[GlobalStatement[Statement:s] GlobalDeclarations:gd Functions:f Statement:s1] ->:a [gd2 f2 s2]
    [s gd f s1] ->:a [GlobalDeclarations:gd2 Functions:f2 Statement:s2]

[GlobalStatement[CompoundGlobalStatement:cgs] GlobalDeclarations:gd Functions:f Statement:s] ->:a [gd1 f1 s1]
    [cgs gd f s] ->:a [GlobalDeclarations:gd1 Functions:f1 Statement:s1]

[CompoundGlobalStatement[GlobalStatement:gs1 newline GlobalStatement:gs2] GlobalDeclarations:gd Functions:f Statement:s] ->:a [gd2 f2 s2]
    [gs1 gd f s] ->:a [GlobalDeclarations:gd1 Functions:f1 Statement:s1]
    [gs2 gd1 f1 s1] ->:a [GlobalDeclarations:gd2 Functions:f2 Statement:s2]

[Interrupt[interrupt ( intLiteral:i ) indent Statement:s1 dedent] GlobalDeclarations:gd Functions:f Statement:s] 
->:a [GlobalDeclarations[GlobalDeclaration[FunctionPrototype[void __vector_21 ( void ) ;]] gd] Functions[Function[void __vector_21 ( void ) { si2 }] f] s]
    i -> intLiteral:i1
    [s1 gd f s] ->:a [GlobalDeclarations:gs1 Functions:f1 Statement:si2]

[Statement[EPSILON] GlobalDeclarations:gd Functions:f Statement:s] ->:a [gd f s]
[Statement[CompoundStatement:s] GlobalDeclarations:gd Functions:f Statement:si] ->:a [gd2 f2 si2]
    [s gd f si] ->:a [GlobalDeclarations:gd2 Functions:f2 Statement:si2]
[Statement[IntegerDeclaration:s] GlobalDeclarations:gd Functions:f Statement:si] ->:a [GlobalDeclarations[GlobalDeclaration[s1 ;] gd] f si]
    s -> IntegerDeclaration:s1
[Statement[BooleanDeclaration:s] GlobalDeclarations:gd Functions:f Statement:si] ->:a [GlobalDeclarations[GlobalDeclaration[s1 ;] gd] f si]
    s -> BooleanDeclaration:s1
[Statement[RegisterDeclaration:s] GlobalDeclarations:gd Functions:f Statement:si] ->:a [GlobalDeclarations[GlobalDeclaration[s1 ;] gd] f si]
    s -> RegisterDeclaration:s1 
[Statement[DirectBitAssignment:s] GlobalDeclarations:gd Functions:f Statement:si] ->:a [gd f Statement[CompoundStatement[Statement[s1 ;] si]]]
    s -> DirectBitAssignment:s1
[Statement[IndirectBitAssignment:s] GlobalDeclarations:gd Functions:f Statement:si] ->:a [gd f Statement[CompoundStatement[Statement[s1 ;] si]]]
    s -> IndirectBitAssignment:s1
[Statement[IntegerAssignment:s] GlobalDeclarations:gd Functions:f Statement:si] ->:a [gd f Statement[CompoundStatement[Statement[s1 ;] si]]]
    s -> IntegerAssignment:s1
[Statement[BooleanAssignment:s] GlobalDeclarations:gd Functions:f Statement:si] ->:a [gd f Statement[CompoundStatement[Statement[s1 ;] si]]]
    s -> BooleanAssignment:s1
[Statement[RegisterAssignment:s] GlobalDeclarations:gd Functions:f Statement:si] ->:a [gd f Statement[CompoundStatement[Statement[s1 ;] si]]]
    s -> RegisterAssignment:s1
[Statement[IfStatement:s] GlobalDeclarations:gd Functions:f Statement:si] ->:a [gd2 f2 si2]
    [s gd f si] ->:a [GlobalDeclarations:gd2 Functions:f2 Statement:si2]
[Statement[WhileStatement:s] GlobalDeclarations:gd Functions:f Statement:si] ->:a [gd2 f2 si2]
    [s gd f si] ->:a [GlobalDeclarations:gd2 Functions:f2 Statement:si2]
[Statement[ForStatement:s] GlobalDeclarations:gd Functions:f Statement:si] ->:a [gd2 f2 si2]
    [s gd f si] ->:a [GlobalDeclarations:gd2 Functions:f2 Statement:si2]
[CompoundStatement[Statement:s1 newline Statement:s2] GlobalDeclarations:gd Functions:f Statement:si] ->:a [gd3 f3 si3]
    [s1 gd f si] ->:a [GlobalDeclarations:gd2 Functions:f2 Statement:si2]
    [s2 gd2 f2 si2] ->:a [GlobalDeclarations:gd3 Functions:f3 Statement:si3]

IntegerDeclaration[intType identifier:id] -> IntegerDeclaration[long long int id1]
    id -> identifier:id1

IntegerAssignment[identifier:id = IntegerExpression:iexpr] -> IntegerAssignment[id1 = iexpr1] 
    id -> identifier:id1
    iexpr -> IntegerExpression:iexpr1

BooleanDeclaration[booleanType:bt identifier:id] -> BooleanDeclaration[char id1]
    id -> identifier:id1

BooleanAssignment[identifier:id = BooleanExpression:bexpr] -> BooleanAssignment[id1 = bexpr1]
    id -> identifier:id1
    bexpr -> BooleanExpression:bexpr1

DirectBitAssignment[registerType ( IntegerExpression:expr1 ) { IntegerExpression:expr2 } = BooleanExpression:bexpr]
-> DirectBitAssignment[( \* ( volatile unsigned char \* ) ( iexpr1 ) ) = ( bexpr1 ? ( ( \* ( volatile unsigned char \* ) ( iexpr1 ) ) | 1 << ( iexpr2 ) ) \: ( ( \* ( volatile unsigned char \* ) ( iexpr1 ) ) & ~ ( 1 << ( iexpr2 ) ) ) )]
    expr1 -> IntegerExpression:iexpr1
    expr2 -> IntegerExpression:iexpr2
    bexpr -> BooleanExpression:bexpr1

IndirectBitAssignment[identifier:id { IntegerExpression:iexpr } = BooleanExpression:bexpr]
-> IndirectBitAssignment[* id1 = ( bexpr1 ? ( ( \* id1 ) | 1 << ( iexpr1 ) ) \: ( ( \* id1 ) & ~ ( 1 << ( iexpr1 ) ) ) )]
    id -> identifier:id1
    iexpr -> IntegerExpression:iexpr1
    bexpr -> BooleanExpression:bexpr1

RegisterDeclaration[registerType identifier:id] -> RegisterDeclaration[volatile unsigned char \* id1]
    id -> identifier:id1

RegisterAssignment[identifier:id = RegisterExpression:rexpr] -> RegisterAssignment[id1 = rexpr1]
    id -> identifier:id1
    rexpr -> RegisterExpression:rexpr1

RegisterExpression[RegisterLiteral:rlit] -> RegisterExpression[rlit1]
    rlit -> RegisterLiteral:rlit1

RegisterExpression[RegisterVariable:rvar] -> RegisterExpression[rvar1]
    rvar -> RegisterVariable:rvar1

RegisterLiteral[registerType ( IntegerExpression:iexpr )] -> RegisterLiteral[( volatile unsigned char \* ) ( iexpr1 )]
    iexpr -> IntegerExpression:iexpr1

RegisterVariable[identifier:id] -> RegisterVariable[id1]
    id -> identifier:id1

[IfStatement[if ( BooleanExpression:bexpr ) indent Statement:s dedent] GlobalDeclarations:gd Functions:f Statement:si] ->:a [gd f Statement[CompoundStatement[Statement[IfStatement[if ( bexpr1 ) { gd3 si3 }]] si]]]
    bexpr -> BooleanExpression:bexpr1
    [s GlobalDeclarations[EPSILON] Functions[EPSILON] Statement[EPSILON]] ->:a [GlobalDeclarations:gd3 Functions:f3 Statement:si3]

[WhileStatement[while ( BooleanExpression:bexpr ) indent Statement:s dedent] GlobalDeclarations:gd Functions:f Statement:si] ->:a [gd f Statement[CompoundStatement[Statement[WhileStatement[while ( bexpr1 ) { gd3 si3 }]] si]]]
    bexpr -> BooleanExpression:bexpr1
    [s GlobalDeclarations[EPSILON] Functions[EPSILON] Statement[EPSILON]] ->:a [GlobalDeclarations:gd3 Functions:f3 Statement:si3]

[ForStatement[for ( intType:t identifier:id from IntegerExpression:expr1 to IntegerExpression:expr2 ) indent Statement:s dedent] GlobalDeclarations:gd Functions:f Statement:si] 
->:a [gd f Statement[CompoundStatement[Statement[ForStatement[for ( long long int id1 = iexpr1 ; id1 <= iexpr2 ; id1 ++ ) { gd3 si3 }]] si]]]
    id -> identifier:id1
    expr1 -> IntegerExpression:iexpr1
    expr2 -> IntegerExpression:iexpr2
    [s GlobalDeclarations[EPSILON] Functions[EPSILON] Statement[EPSILON]] ->:a [GlobalDeclarations:gd3 Functions:f3 Statement:si3]

IntegerExpression[IntegerVariable:s] -> IntegerExpression[s1]
    s -> IntegerVariable:s1
IntegerExpression[IntegerParenthesisExpression:s] -> IntegerExpression[s1]
    s -> IntegerParenthesisExpression:s1
IntegerExpression[AddExpression:s] -> IntegerExpression[s1]
    s -> AddExpression:s1
IntegerExpression[SubExpression:s] -> IntegerExpression[s1]
    s -> SubExpression:s1
IntegerExpression[MulExpression:s] -> IntegerExpression[s1]
    s -> MulExpression:s1
IntegerExpression[DivExpression:s] -> IntegerExpression[s1]
    s -> DivExpression:s1 
IntegerExpression[ModExpression:s] -> IntegerExpression[s1]
    s -> ModExpression:s1
IntegerExpression[PowExpression:s] -> IntegerExpression[s1]
    s -> PowExpression:s1
IntegerExpression[intLiteral:s] -> IntegerExpression[s1]
    s -> intLiteral:s1

IntegerVariable[identifier:id] -> IntegerVariable[id1]
    id -> identifier:id1

IntegerParenthesisExpression[( IntegerExpression:iexpr )] -> IntegerParenthesisExpression[( iexpr1 )]
    iexpr -> IntegerExpression:iexpr1

AddExpression[IntegerExpression:iexpr1 + IntegerExpression:iexpr2] -> AddExpression[( iexpr3 + iexpr4 )]
    iexpr1 -> IntegerExpression:iexpr3
    iexpr2 -> IntegerExpression:iexpr4

SubExpression[IntegerExpression:iexpr1 - IntegerExpression:iexpr2] -> SubExpression[( iexpr3 - iexpr4 )]
    iexpr1 -> IntegerExpression:iexpr3
    iexpr2 -> IntegerExpression:iexpr4

MulExpression[IntegerExpression:iexpr1 \* IntegerExpression:iexpr2] -> MulExpression[( iexpr3 \* iexpr4 )]
    iexpr1 -> IntegerExpression:iexpr3
    iexpr2 -> IntegerExpression:iexpr4

DivExpression[IntegerExpression:iexpr1 / IntegerExpression:iexpr2] -> DivExpression[( iexpr3 / iexpr4 )]
    iexpr1 -> IntegerExpression:iexpr3
    iexpr2 -> IntegerExpression:iexpr4

ModExpression[IntegerExpression:iexpr1 \% IntegerExpression:iexpr2] -> ModExpression[( iexpr3 \% iexpr4 )]
    iexpr1 -> IntegerExpression:iexpr3
    iexpr2 -> IntegerExpression:iexpr4

PowExpression[IntegerExpression:iexpr1 ^ IntegerExpression:iexpr2] -> PowExpression[( iexpr3 \* iexpr4 )]
    iexpr1 -> IntegerExpression:iexpr3
    iexpr2 -> IntegerExpression:iexpr4

BooleanExpression[true] -> BooleanExpression[1]
BooleanExpression[false] -> BooleanExpression[0]
BooleanExpression[BooleanVariable:s] -> BooleanExpression[s1]
    s -> BooleanVariable:s1
BooleanExpression[DirectBitValue:s] -> BooleanExpression[s1]
    s -> DirectBitValue:s1
BooleanExpression[IndirectBitValue:s] -> BooleanExpression[s1]
    s -> IndirectBitValue:s1
BooleanExpression[BooleanParenthesisExpression:s] -> BooleanExpression[s1]
    s -> BooleanParenthesisExpression:s1
BooleanExpression[IntegerEqExpression:s] -> BooleanExpression[s1]
    s -> IntegerEqExpression:s1 
BooleanExpression[BooleanEqExpression:s] -> BooleanExpression[s1]
    s -> BooleanEqExpression:s1 
BooleanExpression[IntegerNotEqExpression:s] -> BooleanExpression[s1]
    s -> IntegerNotEqExpression:s1 
BooleanExpression[BooleanNotEqExpression:s] -> BooleanExpression[s1]
    s -> BooleanNotEqExpression:s1 
BooleanExpression[LessThanExpression:s] -> BooleanExpression[s1]
    s -> LessThanExpression:s1 
BooleanExpression[GreaterThanExpression:s] -> BooleanExpression[s1]
    s -> GreaterThanExpression:s1
BooleanExpression[LessThanOrEqExpression:s] -> BooleanExpression[s1]
    s -> LessThanOrEqExpression:s1 
BooleanExpression[GreaterThanOrEqExpression:s] -> BooleanExpression[s1]
    s -> GreaterThanOrEqExpression:s1 
BooleanExpression[NotExpression:s] -> BooleanExpression[s1]
    s -> NotExpression:s1 
BooleanExpression[AndExpression:s] -> BooleanExpression[s1]
    s -> AndExpression:s1 
BooleanExpression[OrExpression:s] -> BooleanExpression[s1]
    s -> OrExpression:s1

BooleanVariable[identifier:id] -> BooleanVariable[id1]
    id -> identifier:id1

DirectBitValue[registerType ( IntegerExpression:iexpr1 ) { IntegerExpression:iexpr2 }]
-> DirectBitValue[( ( \* ( volatile unsigned char \* ) ( iexpr3 ) ) & ( 1 << ( iexpr4 ) ) )]
    iexpr1 -> IntegerExpression:iexpr3
    iexpr2 -> IntegerExpression:iexpr4

IndirectBitValue[RegisterVariable:rvar { IntegerExpression:iexpr }]
-> IndirectBitValue[( \* rvar1 & ( 1 << ( iexpr1 ) ) )]
    rvar -> RegisterVariable:rvar1
    iexpr -> IntegerExpression:iexpr1

BooleanParenthesisExpression[( BooleanExpression:bexpr )] -> BooleanParenthesisExpression[( bexpr1 )]
    bexpr -> BooleanExpression:bexpr1

IntegerEqExpression[IntegerExpression:iexpr1 = IntegerExpression:iexpr2] -> IntegerEqExpression[( iexpr3 == iexpr4 )]
    iexpr1 -> IntegerExpression:iexpr3
    iexpr2 -> IntegerExpression:iexpr4

BooleanEqExpression[BooleanExpression:bexpr1 = BooleanExpression:bexpr2] -> BooleanEqExpression[( bexpr3 == bexpr4 )]
    bexpr1 -> BooleanExpression:bexpr3
    bexpr2 -> BooleanExpression:bexpr4

IntegerNotEqExpression[IntegerExpression:iexpr1 != IntegerExpression:iexpr2] -> IntegerNotEqExpression[( iexpr3 != iexpr4 )]
    iexpr1 -> IntegerExpression:iexpr3
    iexpr2 -> IntegerExpression:iexpr4

BooleanNotEqExpression[BooleanExpression:bexpr1 != BooleanExpression:bexpr2] -> BooleanNotEqExpression[( bexpr3 != bexpr4 )]
    bexpr1 -> BooleanExpression:bexpr3
    bexpr2 -> BooleanExpression:bexpr4

LessThanExpression[IntegerExpression:iexpr1 < IntegerExpression:iexpr2] -> LessThanExpression[( iexpr3 < iexpr4 )]
    iexpr1 -> IntegerExpression:iexpr3
    iexpr2 -> IntegerExpression:iexpr4

GreaterThanExpression[IntegerExpression:iexpr1 > IntegerExpression:iexpr2] -> GreaterThanExpression[( iexpr3 > iexpr4 )]
    iexpr1 -> IntegerExpression:iexpr3
    iexpr2 -> IntegerExpression:iexpr4

LessThanOrEqExpression[IntegerExpression:iexpr1 <= IntegerExpression:iexpr2] -> LessThanOrEqExpression[( iexpr3 <= iexpr4 )]
    iexpr1 -> IntegerExpression:iexpr3
    iexpr2 -> IntegerExpression:iexpr4

GreaterThanOrEqExpression[IntegerExpression:iexpr1 >= IntegerExpression:iexpr2] -> GreaterThanOrEqExpression[( iexpr3 >= iexpr4 )]
    iexpr1 -> IntegerExpression:iexpr3
    iexpr2 -> IntegerExpression:iexpr4

NotExpression[! BooleanExpression:bexpr] -> NotExpression[( ! bexpr1 )]
    bexpr -> BooleanExpression:bexpr1

AndExpression[BooleanExpression:bexpr1 and BooleanExpression:bexpr2] -> AndExpression[( bexpr3 && bexpr4 )]
    bexpr1 -> BooleanExpression:bexpr3
    bexpr2 -> BooleanExpression:bexpr4

OrExpression[BooleanExpression:bexpr1 or BooleanExpression:bexpr2] -> OrExpression[( bexpr3 || bexpr4 )]
    bexpr1 -> BooleanExpression:bexpr3
    bexpr2 -> BooleanExpression:bexpr4
