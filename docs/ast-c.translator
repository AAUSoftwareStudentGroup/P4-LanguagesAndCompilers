-> := AST -> C

AST[GlobalStatement:gs eof] -> C[Main[int main ( void ) { gs1 }]]
    gs -> GlobalStatement:gs1

GlobalStatement[CompoundGlobalStatement:cgs] -> GlobalStatement[cgs1]
    cgs -> CompoundGlobalStatement:cgs1

GlobalStatement[Statement:s] -> GlobalStatement[s1]
    s -> Statement:s1

CompoundGlobalStatement[GlobalStatement:gs1 newline GlobalStatement:gs2] -> CompoundGlobalStatement[gs3 gs4]
    gs1 -> GlobalStatement:gs3
    gs2 -> GlobalStatement:gs4

Statement[EPSILON] -> Statement
Statement[CompoundStatement:s] -> Statement[s1]
    s -> CompoundStatement:s1
Statement[IntegerDeclaration:s] -> Statement[s1 ;]
    s -> IntegerDeclaration:s1
Statement[BooleanDeclaration:s] -> Statement[s1 ;]
    s -> BooleanDeclaration:s1
Statement[DirectBitAssignment:s] -> Statement[s1 ;]
    s -> DirectBitAssignment:s1
Statement[IndirectBitAssignment:s] -> Statement[s1 ;]
    s -> IndirectBitAssignment:s1
Statement[RegisterDeclaration:s] -> Statement[s1 ;]
    s -> RegisterDeclaration:s1 
Statement[IntegerAssignment:s] -> Statement[s1 ;]
    s -> IntegerAssignment:s1
Statement[BooleanAssignment:s] -> Statement[s1 ;]
    s -> BooleanAssignment:s1
Statement[RegisterAssignment:s] -> Statement[s1 ;]
    s -> RegisterAssignment:s1
Statement[IfStatement:s] -> Statement[s1]
    s -> IfStatement:s1 
Statement[WhileStatement:s] -> Statement[s1]
    s -> WhileStatement:s1

CompoundStatement[Statement:s1 newline Statement:s2] -> CompoundStatement[s3 s4]
    s1 -> Statement:s3
    s2 -> Statement:s4

IntegerDeclaration[intType identifier:id] -> IntegerDeclaration[long long int id1]
    id -> identifier:id1
		   
IntegerAssignment[identifier:id = IntegerExpression:iexpr] -> IntegerAssignment[id1 = iexpr1] 
    id -> identifier:id1
    iexpr -> IntegerExpression:iexpr1

BooleanDeclaration[booleanType:bt identifier:id] -> BooleanDeclaration[bt1 id1]
    bt -> booleanType:bt1 
    id -> identifier:id1

BooleanAssignment[identifier:id = BooleanExpression:bexpr] -> BooleanAssignment[id1 = bexpr1]
    id -> identifier:id1
    bexpr -> BooleanExpression:bexpr1

DirectBitAssignment[registerType ( intLiteral:i ) { IntegerExpression:iexpr } = BooleanExpression:bexpr]
-> DirectBitAssignment[( * ( volatile unsigned char * ) ( i1 ) ) = ( bexpr1 ? ( ( * ( volatile unsigned char * ) ( i1 ) ) | 1 << ( iexpr1 ) ) $ ( ( * ( volatile unsigned char * ) ( i1 ) ) & ! ( 1 << ( iexpr1 ) ) ) )]
    i -> intLiteral:i1
    iexpr -> IntegerExpression:iexpr1
    bexpr -> BooleanExpression:bexpr1

IndirectBitAssignment[identifier:id { IntegerExpression:iexpr } = BooleanExpression:bexpr]
-> IndirectBitAssignment[* id1 = ( bexpr1 ? ( ( * id1 ) | 1 << ( iexpr1 ) ) $ ( ( * id1 ) & ! ( 1 << ( iexpr1 ) ) ) )]
    id -> identifier:id1
    iexpr -> IntegerExpression:iexpr1
    bexpr -> BooleanExpression:bexpr1

RegisterDeclaration[registerType identifier:id] -> RegisterDeclaration[volatile unsigned char * id1]
    id -> identifier:id1

RegisterAssignment[identifier:id = RegisterExpression:rexpr] -> RegisterAssignment[id1 = rexpr1]
    id -> identifier:id1
    rexpr -> RegisterExpression:rexpr1

RegisterExpression[RegisterLiteral:rlit] -> RegisterExpression[rlit1]
    rlit -> RegisterLiteral:rlit1

RegisterExpression[RegisterVariable:rvar] -> RegisterExpression[rvar1]
    rvar -> RegisterVariable:rvar1

RegisterLiteral[registerType ( intLiteral:i )] -> RegisterLiteral[( volatile unsigned char * ) ( i1 )]
    i -> intLiteral:i1

RegisterVariable[identifier:id] -> RegisterVariable[id1]
    id -> identifier:id1

IfStatement[if ( BooleanExpression:bexpr ) indent Statement:s dedent] -> IfStatement[if ( bexpr1 ) { s1 }] 
    bexpr -> BooleanExpression:bexpr1
    s -> Statement:s1

WhileStatement[while ( BooleanExpression:bexpr ) indent Statement:s dedent] -> WhileStatement[while ( bexpr1 ) { s1 }]
    bexpr -> BooleanExpression:bexpr1
    s -> Statement:s1

IntegerExpression[IntegerVariable:s] -> IntegerExpression[s1]
    s -> IntegerVariable:s1
IntegerExpression[IntegerParenthesisExpression:s] -> IntegerExpression[s1]
    s -> IntegerParenthesisExpression:s1
IntegerExpression[AddExpression:s] -> IntegerExpression[s1]
    s -> AddExpression:s1
IntegerExpression[SubExpression:s] -> IntegerExpression[s1]
    s -> SubExpression:s1
IntegerExpression[MulExpression:s] -> IntegerExpression[s1]
    s -> MulExpression:s1
IntegerExpression[DivExpression:s] -> IntegerExpression[s1]
    s -> DivExpression:s1 
IntegerExpression[intLiteral:s] -> IntegerExpression[s1]
    s -> intLiteral:s1

IntegerVariable[identifier:id] -> IntegerVariable[id1]
    id -> identifier:id1

IntegerParenthesisExpression[( IntegerExpression:iexpr )] -> IntegerParenthesisExpression[( iexpr1 )]
    iexpr -> IntegerExpression:iexpr1

AddExpression[IntegerExpression:iexpr1 + IntegerExpression:iexpr2] -> AddExpression[( iexpr3 + iexpr4 )]
    iexpr1 -> IntegerExpression:iexpr3
    iexpr2 -> IntegerExpression:iexpr4

SubExpression[IntegerExpression:iexpr1 - IntegerExpression:iexpr2] -> SubExpression[( iexpr3 - iexpr4 )]
    iexpr1 -> IntegerExpression:iexpr3
    iexpr2 -> IntegerExpression:iexpr4

MulExpression[IntegerExpression:iexpr1 * IntegerExpression:iexpr2] -> MulExpression[( iexpr3 * iexpr4 )]
    iexpr1 -> IntegerExpression:iexpr3
    iexpr2 -> IntegerExpression:iexpr4

DivExpression[IntegerExpression:iexpr1 / IntegerExpression:iexpr2] -> DivExpression[( iexpr3 / iexpr4 )]
    iexpr1 -> IntegerExpression:iexpr3
    iexpr2 -> IntegerExpression:iexpr4

BooleanExpression[true] -> BooleanExpression[1]
BooleanExpression[false] -> BooleanExpression[0]
BooleanExpression[BooleanVariable:s] -> BooleanExpression[s1]
    s -> BooleanVariable:s1
BooleanExpression[DirectBitValue:s] -> BooleanExpression[s1]
    s -> DirectBitValue:s1
BooleanExpression[IndirectBitValue:s] -> BooleanExpression[s1]
    s -> IndirectBitValue:s1
BooleanExpression[BooleanParenthesisExpression:s] -> BooleanExpression[s1]
    s -> BooleanParenthesisExpression:s1
BooleanExpression[IntegerEqExpression:s] -> BooleanExpression[s1]
    s -> IntegerEqExpression:s1 
BooleanExpression[BooleanEqExpression:s] -> BooleanExpression[s1]
    s -> BooleanEqExpression:s1 
BooleanExpression[LessThanExpression:s] -> BooleanExpression[s1]
    s -> LessThanExpression:s1 
BooleanExpression[GreaterThanExpression:s] -> BooleanExpression[s1]
    s -> GreaterThanExpression:s1
BooleanExpression[NotExpression:s] -> BooleanExpression[s1]
    s -> NotExpression:s1 
BooleanExpression[AndExpression:s] -> BooleanExpression[s1]
    s -> AndExpression:s1 
BooleanExpression[OrExpression:s] -> BooleanExpression[s1]
    s -> OrExpression:s1

BooleanVariable[identifier:id] -> BooleanVariable[id1]
    id -> identifier:id1

DirectBitValue[registerType ( intLiteral:i ) { IntegerExpression:iexpr }]
-> DirectBitValue[( ( * ( volatile unsigned char * ) ( i1 ) ) & ( 1 << ( iexpr1 ) ) )]
    i -> intLiteral:i1
    iexpr -> IntegerExpression:iexpr1

IndirectBitValue[RegisterVariable:rvar { IntegerExpression:iexpr }]
-> IndirectBitValue[( * rvar1 & ( 1 << ( iexpr1 ) ) )]
    rvar -> RegisterVariable:rvar1
    iexpr -> IntegerExpression:iexpr1

BooleanParenthesisExpression[( BooleanExpression:bexpr )] -> BooleanParenthesisExpression[( bexpr1 )]
    bexpr -> BooleanExpression:bexpr1

IntegerEqExpression[IntegerExpression:iexpr1 = IntegerExpression:iexpr2] -> IntegerEqExpression[( iexpr3 == iexpr4 )]
    iexpr1 -> IntegerExpression:iexpr3
    iexpr2 -> IntegerExpression:iexpr4

BooleanEqExpression[BooleanExpression:bexpr1 = BooleanExpression:bexpr2] -> BooleanEqExpression[( bexpr3 == bexpr4 )]
    bexpr1 -> BooleanExpression:bexpr3
    bexpr2 -> BooleanExpression:bexpr4

LessThanExpression[IntegerExpression:iexpr1 < IntegerExpression:iexpr2] -> LessThanExpression[( iexpr3 < iexpr4 )]
    iexpr1 -> IntegerExpression:iexpr3
    iexpr2 -> IntegerExpression:iexpr4

GreaterThanExpression[IntegerExpression:iexpr1 > IntegerExpression:iexpr2] -> GreaterThanExpression[( iexpr3 > iexpr4 )]
    iexpr1 -> IntegerExpression:iexpr3
    iexpr2 -> IntegerExpression:iexpr4

NotExpression[! BooleanExpression:bexpr] -> NotExpression[( ! bexpr1 )]
    bexpr -> BooleanExpression:bexpr1

AndExpression[BooleanExpression:bexpr1 and BooleanExpression:bexpr2] -> AndExpression[( bexpr3 && bexpr4 )]
    bexpr1 -> BooleanExpression:bexpr3
    bexpr2 -> BooleanExpression:bexpr4

OrExpression[BooleanExpression:bexpr1 or BooleanExpression:bexpr2] -> OrExpression[( bexpr3 || bexpr4 )]
    bexpr1 -> BooleanExpression:bexpr3
    bexpr2 -> BooleanExpression:bexpr4
